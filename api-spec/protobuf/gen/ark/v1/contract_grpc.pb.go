// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: ark/v1/contract.proto

package arkv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ContractService_CreateContract_FullMethodName         = "/ark.v1.ContractService/CreateContract"
	ContractService_GetContract_FullMethodName            = "/ark.v1.ContractService/GetContract"
	ContractService_SetupContract_FullMethodName          = "/ark.v1.ContractService/SetupContract"
	ContractService_SettleContract_FullMethodName         = "/ark.v1.ContractService/SettleContract"
	ContractService_ListContracts_FullMethodName          = "/ark.v1.ContractService/ListContracts"
	ContractService_GetHashrate_FullMethodName            = "/ark.v1.ContractService/GetHashrate"
	ContractService_GetHistoricalHashrates_FullMethodName = "/ark.v1.ContractService/GetHistoricalHashrates"
	ContractService_CheckSettlement_FullMethodName        = "/ark.v1.ContractService/CheckSettlement"
	ContractService_GetContractEvents_FullMethodName      = "/ark.v1.ContractService/GetContractEvents"
)

// ContractServiceClient is the client API for ContractService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContractServiceClient interface {
	CreateContract(ctx context.Context, in *CreateContractRequest, opts ...grpc.CallOption) (*CreateContractResponse, error)
	GetContract(ctx context.Context, in *GetContractRequest, opts ...grpc.CallOption) (*GetContractResponse, error)
	SetupContract(ctx context.Context, in *SetupContractRequest, opts ...grpc.CallOption) (*SetupContractResponse, error)
	SettleContract(ctx context.Context, in *SettleContractRequest, opts ...grpc.CallOption) (*SettleContractResponse, error)
	ListContracts(ctx context.Context, in *ListContractsRequest, opts ...grpc.CallOption) (*ListContractsResponse, error)
	GetHashrate(ctx context.Context, in *GetHashrateRequest, opts ...grpc.CallOption) (*GetHashrateResponse, error)
	GetHistoricalHashrates(ctx context.Context, in *GetHistoricalHashratesRequest, opts ...grpc.CallOption) (*GetHistoricalHashratesResponse, error)
	CheckSettlement(ctx context.Context, in *CheckSettlementRequest, opts ...grpc.CallOption) (*CheckSettlementResponse, error)
	GetContractEvents(ctx context.Context, in *GetContractEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetContractEventsResponse], error)
}

type contractServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewContractServiceClient(cc grpc.ClientConnInterface) ContractServiceClient {
	return &contractServiceClient{cc}
}

func (c *contractServiceClient) CreateContract(ctx context.Context, in *CreateContractRequest, opts ...grpc.CallOption) (*CreateContractResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateContractResponse)
	err := c.cc.Invoke(ctx, ContractService_CreateContract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractServiceClient) GetContract(ctx context.Context, in *GetContractRequest, opts ...grpc.CallOption) (*GetContractResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetContractResponse)
	err := c.cc.Invoke(ctx, ContractService_GetContract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractServiceClient) SetupContract(ctx context.Context, in *SetupContractRequest, opts ...grpc.CallOption) (*SetupContractResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetupContractResponse)
	err := c.cc.Invoke(ctx, ContractService_SetupContract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractServiceClient) SettleContract(ctx context.Context, in *SettleContractRequest, opts ...grpc.CallOption) (*SettleContractResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SettleContractResponse)
	err := c.cc.Invoke(ctx, ContractService_SettleContract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractServiceClient) ListContracts(ctx context.Context, in *ListContractsRequest, opts ...grpc.CallOption) (*ListContractsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListContractsResponse)
	err := c.cc.Invoke(ctx, ContractService_ListContracts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractServiceClient) GetHashrate(ctx context.Context, in *GetHashrateRequest, opts ...grpc.CallOption) (*GetHashrateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHashrateResponse)
	err := c.cc.Invoke(ctx, ContractService_GetHashrate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractServiceClient) GetHistoricalHashrates(ctx context.Context, in *GetHistoricalHashratesRequest, opts ...grpc.CallOption) (*GetHistoricalHashratesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHistoricalHashratesResponse)
	err := c.cc.Invoke(ctx, ContractService_GetHistoricalHashrates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractServiceClient) CheckSettlement(ctx context.Context, in *CheckSettlementRequest, opts ...grpc.CallOption) (*CheckSettlementResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckSettlementResponse)
	err := c.cc.Invoke(ctx, ContractService_CheckSettlement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractServiceClient) GetContractEvents(ctx context.Context, in *GetContractEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetContractEventsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ContractService_ServiceDesc.Streams[0], ContractService_GetContractEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetContractEventsRequest, GetContractEventsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ContractService_GetContractEventsClient = grpc.ServerStreamingClient[GetContractEventsResponse]

// ContractServiceServer is the server API for ContractService service.
// All implementations must embed UnimplementedContractServiceServer
// for forward compatibility.
type ContractServiceServer interface {
	CreateContract(context.Context, *CreateContractRequest) (*CreateContractResponse, error)
	GetContract(context.Context, *GetContractRequest) (*GetContractResponse, error)
	SetupContract(context.Context, *SetupContractRequest) (*SetupContractResponse, error)
	SettleContract(context.Context, *SettleContractRequest) (*SettleContractResponse, error)
	ListContracts(context.Context, *ListContractsRequest) (*ListContractsResponse, error)
	GetHashrate(context.Context, *GetHashrateRequest) (*GetHashrateResponse, error)
	GetHistoricalHashrates(context.Context, *GetHistoricalHashratesRequest) (*GetHistoricalHashratesResponse, error)
	CheckSettlement(context.Context, *CheckSettlementRequest) (*CheckSettlementResponse, error)
	GetContractEvents(*GetContractEventsRequest, grpc.ServerStreamingServer[GetContractEventsResponse]) error
	mustEmbedUnimplementedContractServiceServer()
}

// UnimplementedContractServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedContractServiceServer struct{}

func (UnimplementedContractServiceServer) CreateContract(context.Context, *CreateContractRequest) (*CreateContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateContract not implemented")
}
func (UnimplementedContractServiceServer) GetContract(context.Context, *GetContractRequest) (*GetContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContract not implemented")
}
func (UnimplementedContractServiceServer) SetupContract(context.Context, *SetupContractRequest) (*SetupContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetupContract not implemented")
}
func (UnimplementedContractServiceServer) SettleContract(context.Context, *SettleContractRequest) (*SettleContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SettleContract not implemented")
}
func (UnimplementedContractServiceServer) ListContracts(context.Context, *ListContractsRequest) (*ListContractsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListContracts not implemented")
}
func (UnimplementedContractServiceServer) GetHashrate(context.Context, *GetHashrateRequest) (*GetHashrateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHashrate not implemented")
}
func (UnimplementedContractServiceServer) GetHistoricalHashrates(context.Context, *GetHistoricalHashratesRequest) (*GetHistoricalHashratesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistoricalHashrates not implemented")
}
func (UnimplementedContractServiceServer) CheckSettlement(context.Context, *CheckSettlementRequest) (*CheckSettlementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckSettlement not implemented")
}
func (UnimplementedContractServiceServer) GetContractEvents(*GetContractEventsRequest, grpc.ServerStreamingServer[GetContractEventsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method GetContractEvents not implemented")
}
func (UnimplementedContractServiceServer) mustEmbedUnimplementedContractServiceServer() {}
func (UnimplementedContractServiceServer) testEmbeddedByValue()                         {}

// UnsafeContractServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContractServiceServer will
// result in compilation errors.
type UnsafeContractServiceServer interface {
	mustEmbedUnimplementedContractServiceServer()
}

func RegisterContractServiceServer(s grpc.ServiceRegistrar, srv ContractServiceServer) {
	// If the following call pancis, it indicates UnimplementedContractServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ContractService_ServiceDesc, srv)
}

func _ContractService_CreateContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServiceServer).CreateContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractService_CreateContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServiceServer).CreateContract(ctx, req.(*CreateContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractService_GetContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServiceServer).GetContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractService_GetContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServiceServer).GetContract(ctx, req.(*GetContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractService_SetupContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetupContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServiceServer).SetupContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractService_SetupContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServiceServer).SetupContract(ctx, req.(*SetupContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractService_SettleContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettleContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServiceServer).SettleContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractService_SettleContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServiceServer).SettleContract(ctx, req.(*SettleContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractService_ListContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListContractsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServiceServer).ListContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractService_ListContracts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServiceServer).ListContracts(ctx, req.(*ListContractsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractService_GetHashrate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHashrateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServiceServer).GetHashrate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractService_GetHashrate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServiceServer).GetHashrate(ctx, req.(*GetHashrateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractService_GetHistoricalHashrates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHistoricalHashratesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServiceServer).GetHistoricalHashrates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractService_GetHistoricalHashrates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServiceServer).GetHistoricalHashrates(ctx, req.(*GetHistoricalHashratesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractService_CheckSettlement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckSettlementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServiceServer).CheckSettlement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractService_CheckSettlement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServiceServer).CheckSettlement(ctx, req.(*CheckSettlementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractService_GetContractEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetContractEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ContractServiceServer).GetContractEvents(m, &grpc.GenericServerStream[GetContractEventsRequest, GetContractEventsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ContractService_GetContractEventsServer = grpc.ServerStreamingServer[GetContractEventsResponse]

// ContractService_ServiceDesc is the grpc.ServiceDesc for ContractService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContractService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ark.v1.ContractService",
	HandlerType: (*ContractServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateContract",
			Handler:    _ContractService_CreateContract_Handler,
		},
		{
			MethodName: "GetContract",
			Handler:    _ContractService_GetContract_Handler,
		},
		{
			MethodName: "SetupContract",
			Handler:    _ContractService_SetupContract_Handler,
		},
		{
			MethodName: "SettleContract",
			Handler:    _ContractService_SettleContract_Handler,
		},
		{
			MethodName: "ListContracts",
			Handler:    _ContractService_ListContracts_Handler,
		},
		{
			MethodName: "GetHashrate",
			Handler:    _ContractService_GetHashrate_Handler,
		},
		{
			MethodName: "GetHistoricalHashrates",
			Handler:    _ContractService_GetHistoricalHashrates_Handler,
		},
		{
			MethodName: "CheckSettlement",
			Handler:    _ContractService_CheckSettlement_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetContractEvents",
			Handler:       _ContractService_GetContractEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ark/v1/contract.proto",
}
